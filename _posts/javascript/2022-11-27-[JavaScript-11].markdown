---
layout: post
title: "[모던JS] 스코프"
date: 2022-11-27 16:18:12 +09:00
excerpt: "모던 자바스크립트 Deep Dive<br>2022-11-27"
javascript: true
categories: javascript
tags: javascript
comments: true
---

# 📌 [모던 자바스크립트 13주 뿌시기] 13. 스코프

---

<figure>
    <a href="/assets/img/JavaScript/2022-11-10/bookcover.png"><img src="/assets/img/JavaScript/2022-11-10/bookcover.png"></a>
    <figcaption style="text-align:center"></figcaption>
</figure>

<br>
<br>

# 13. 스코프 

### 스코프란?
모든 식별자(변수 이름, 함수 이름, 클래스 이름 등)가 자신이 선언된 위치에 의해 다른 코드가 식별자를 참조할 수 있는 유효 범위.
즉, 스코프는 식별자가 유효한 범위를 뜻함.
또는 식별자를 검색할 때 사용하는 규칙이기도 하다.

<br>

#### 예시
```javascript
var x = 'global';

function foo() {
    var x = 'local';
    console.log(x);
}

foo();  // local

console.log(x); // global
```

`foo()` 함수 내부에서 전역에 선언된 `x`와 함수 내부에 선언된 `x`가 충돌을 일으키고 있다.

JS 엔진은 어떤 변수를 참조해야하는지 결정하게 되는데 이를 **식별자 결정**이라고 한다. 
`x`를 참조할 때, 참조할 때의 유효 스코프에서 어떤 `x`를 참조할지 식별자 결정이 발생한다.


<br>
<br>

### 스코프의 종류

|구분|설명|스코프|변수|
|----|---|---|---|
|전역|코드의 가장 바깥 영역|전역 스코프|전역 변수|
|지역|함수 몸체 내부|지역 스코프|지역 변수|

변수는 변수가 선언된 위치에 의해 자신이 유효한 범위인 스코프가 결정된다.

**전역에서 선언 > 전역 스코프**
**지역에서 선언 > 지역 스코프**

```javascript
let x = 1;

function a (){
    let y = 2;
    
    function b(){
        let x = 10;
        let z = 3;

        return x + y + z;
    }

    return b();
}

a();    // 15

```

위 예시에서 전역 스코프에 해당하는 변수는 `x`
지역 스코프에 해당하는 변수는 `y`, `z`

그러나 함수는 중첩될 수 있으므로 지역 스코프 또한 중첩될 수 있다.
이러한 특성은 스코프가 함수의 중첩에 의해 **계층적 구조**를 가진다는 것을 알 수 있다.

<br>

### 스코프 체인
모든 스코프는 하나의 계층적 구조로 연결되는데, 이때 계층적으로 연결된 것을 **스코프 체인**이라 한다.

상위 스코프: 상대적으로 전역 스코프에 가까운 스코프
하위 스코프: 상대적으로 내부에 있는 지역 스코프

위의 예시에서 전역 스코프, `a()` 지역 스코프, `b()` 지역 스코프로 나눌 수 있다.
JS 엔진이 변수를 참조할 때 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다.

<br>

**ex) 상위 스코프 방향으로 변수 검색**
1. `b()`: `x`, `y`, `z`를 검색하여 `x`와 `z` 변수를 검색함
2. `a()`: `y`, `z`를 검색하여 `y`를 검색함
3. 전역: `x`가 있으나 이미 하위 스코프에서 검색종료 되었다.

이런 방식으로 하위에서 상위로 검색하기 때문에 상위 스코프에서 유효한 변수는 하위 스코프에서 자유롭게 참조할 수 있지만 하위 스코프에서 유효한 변수를 상위 스코프에서 참조할 수 없다.

위의 예시는 변수의 경우에만 예시를 들었지만 함수 식별자의 경우에도 유사한 결과를 나타낸다.

```javascript
function foo() {
    console.log('전역의 foo');
}

function bar() {
    // 중첩 함수
    function foo() {
        console.log('지역 함수의 foo');
    }

    foo();
}

bar();
```
1. `bar()`: `bar()`의 하위 스코프 `foo()`를 검색함
2. 전역: `foo()`가 있으나 이미 하위 스코프에서 `foo()`에 대한 검색이 종료 되었다.

<br>
<br>

### 함수 레벨 스코프
블록 레벨 스코프: 모든 블록문(`if`, `for`, `while` ...) 내에서 지역 스코프를 만드는 것.
함수 레벨 스코프: 함수의 코드 블록만을 지역 스코프로 만드는 것.

`var` 키워드로 선언된 변수는 **함수 레벨 스코프**를 갖는다.
`let`, `const` 키워드로 선언된 변수는 **블록 레벨 스코프**를 갖는다.

**즉,** `var` **키워드로 변수를 코드 블록 내에서 선언하더라도 전역 변수로 취급한다.**

```javascript
var a = 500;
var b = 300;

// 블록문
if(true){
    var a = 50;
    let b = 2;
    var c = 70;

    console.log(b); // 2;
}

// 함수
function test() {
    var d = 0;
}

test();

console.log(a); // 50
console.log(b); // 300
console.log(c); // 70
console.log(d); // Uncaught ReferenceError: d is not defined
```
- `a`는 `if`의 블록문에서 선언하였으나, `var` 키워드로 선언하였으므로 지역 스코프로 인정되지 않고 전역으로 인정되기 때문에 전역 변수 `a`의 값이 바뀐다.
- `b`는 전역에서 선언 후 또 `if`의 블록문에서 선언되었는데 `let` 키워드로 선언하여 지역 스코프로 인정되므로 `if`문 내에서는 `2`가 출력되지만 전역에서 출력할 때는 전역 스코프의 값인 `300`이 출력된다.
- `c`는 블록문에서 선언되었고 함수 레벨 스코프이므로 전역 스코프에 생성되어 전역에서 출력하였을 때 값이 출력된다.
- `d`는 함수 내부에서 선언되었는데, `var`는 다른 블록문과 다르게 함수 내부에서 선언되는 것은 지역 스코프로 인정하기 때문에 지역 내에서만 선언되고 전역에서 출력했을 때는 에러를 발생한다.

<br>
<br>

### 렉시컬 스코프
**동적 스코프**: 함수를 어디서 **호출**했는지에 따라 함수의 상위 스코프를 결정하는 방식.
**렉시컬 스코프**: 함수를 어디서 **정의**했는지에 따라 함수의 상위 스코프를 결정하는 방식.

JS를 비롯한 대부분의 언어는 **렉시컬 스코프**를 따름.

```javascript
var x = 1;

function foo() {
    var x = 10;
    bar();
}

function bar() {
    console.log(x);
}

foo();  // 1
bar();  // 1
```
JS가 렉시컬 스코프를 따르기 때문에 `bar()`가 정의되었을 때, 상위 스코프는 항상 전역이기 때문에 `bar()`를 `foo()`에서 호출하여도 1이 출력된다.

렉시컬 스코프는 함수가 정의될 때 정적으로 결과도 정해진다.
그러나, 동적 스코프는 호출할 때 어디서 호출했냐에 따라 동적으로 그 결과가 달라진다.










<br>
<br>
<br>
<br>

### 출처

위키북스, 『모던 자바스크립트 Deep Dive』, 이웅모

[jekyll-docs]: https://jekyllrb.com/docs/home
[jekyll-gh]: https://github.com/jekyll/jekyll
[jekyll-talk]: https://talk.jekyllrb.com/
